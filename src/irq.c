/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *
 *
 * src/irq.c
 *
 * IRQ service routine
 *
 * Author:	Daniel Kudrow (dkudrow@cs.ucsb.edu)
 * Date:	April 19 2014
 *
 * Copyright (c) 2014, Daniel Kudrow
 * All rights reserved, see LICENSE.txt for details.
 *
 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *
 * The interrupt controller's job on the BCM2835 is fairly straightforward:
 * it collects interrupt signals coming from the peripherals. It's
 * interface consists of three types of registers:
 *
 *	1. 'Pending' registers are used to determine which peripheral(s)
 *	generated an interrupt. Each bit of these registers corresponds to
 *	a peripheral on the board.
 *
 *	2. 'Enable' registers are used to allow a peripheral to generate
 *	interrupts. Setting a peripheral's bit here enables interrupts from
 *	it.
 *
 *	2. 'Disable' registers are used to prevent a peripheral from
 *	generating interrupts. Setting a peripheral's bit here disables
 *	interrupts from	it.
 *
 * So far so good.
 */

#define MODULE IRQ

#include <irq.h>
#include <log.h>
#include <platform.h>

static volatile irq_reg_t *irq = IRQ_BASE;

static irq_handler_t irq_handlers[96];

/*
 * Register a service routine with the interrupt handler
 */
void irq_register_handler(irq_handler_t handler, int pos)
{
	irq_handlers[pos] = handler;
}

/*
 * Banked interrupt service routine
 *
 * If bit 8 or 9 was set in the basic pending register, there is an
 * interrupt waiting for us in bank 1 or 2 (respectively). This routine
 * checks the appropriate bank and invokes the correct handler.
 */
static void irq_handle_pending(int bank)
{
	int bit;
	uint32_t pending = irq->pending[bank-1];

	while (pending) {
		bit = 31 - __builtin_clz(pending);
		(irq_handlers[bank * 64 + bit])();
		pending ^= (1 << bit); 
	}
}

/*
 * Service an interrupt in bank 1
 */
void irq_handle_bank_1_pending(void)
{
	irq_handle_pending(1);
}

/*
 * Service an interrupt in bank 2
 */
void irq_handle_bank_2_pending(void)
{
	irq_handle_pending(2);
}

/*
 * Initialize the interrupt service routine
 */
void irq_init()
{
	irq_register_handler(irq_handle_bank_1_pending, 8);
	irq_register_handler(irq_handle_bank_2_pending, 9);
}

/*
 * Interrupt service routine
 *
 * When servicing an interrupt, we only check the basic pending register.
 * If an interrupt was generated by a peripheral mapped to bank 1 or 2, bit
 * 8 or 9 (respectively) will be set. The interrupt handlers for these two
 * bits will check the corresponding pending register and finish servicing
 * the interrupt.
 */
void service_irq()
{
	int bit;
	uint32_t pending;

	log(DEBUG, "basic_pend: 0x%x, pend_1: 0x%x, pend_2: 0x%x", irq->basic_pending, irq->pending[1], irq->pending[1]);
	log(DEBUG, "basic_enbl: 0x%x, enbl_1: 0x%x, enbl_2: 0x%x", irq->basic_enable, irq->enable[0], irq->enable[1]);
	log(DEBUG, "basic_dabl: 0x%x, dabl_1: 0x%x, dabl_2: 0x%x", irq->basic_disable, irq->disable[0], irq->disable[1]);

	pending = irq->basic_pending;
	while (pending) {
		bit = 31 - __builtin_clz(pending);
		(irq_handlers[bit])();
		pending ^= (1 << bit); 
	}
}

void service_undefined()
{
	log(WARN, "handling undefined");
}

void service_software_int()
{
	log(WARN, "handling software_int");
}

void service_prefetch_abort()
{
	log(WARN, "handling prefetch_abort");
}

void service_data_abort()
{
	log(WARN, "handling data_abort");
}

void service_fiq()
{
	log(WARN, "handling fiq");
}
