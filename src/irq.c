/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *
 *
 * src/irq.c
 *
 * IRQ service routine
 *
 * Author:	Daniel Kudrow (dkudrow@cs.ucsb.edu)
 * Date:	April 19 2014
 *
 * Copyright (c) 2014, Daniel Kudrow
 * All rights reserved, see LICENSE.txt for details.
 *
 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *
 * The interrupt controller's job on the BCM2835 is fairly straightforward:
 * it collects interrupt signals coming from the peripherals. It's
 * interface consists of three types of registers:
 *
 *	1. 'Pending' registers are used to determine which peripheral(s)
 *	generated an IRQ. Each bit of these registers corresponds to a
 *	peripheral on the board.
 *
 *	2. 'Enable' registers are used to allow a peripheral to generate
 *	IRQs. Setting a peripheral's bit here enables IRQs from it.
 *
 *	3. 'Disable' registers are used to prevent a peripheral from
 *	generating IRQs. Setting a peripheral's bit here disables IRQs
 *	from it.
 *
 * When we receive an IRQ we check the 'basic' pending register. The first
 * 8 bits of this register correspond to peripherals controlled by the ARM
 * core. If any of these are set, we invoke the corresponding service
 * routine. The next two bits are set when an IRQ is pending in one of the
 * other two banks. In this case we check the pending register in the
 * corresponding bank and invoke the correct service routine. Finally the
 * next eleven bits are 'shortcuts' to common IRQs that live the other two
 * banks. For instance the USB pending bit is found in the first bank.
 * However when the USB controller generates an IRQ, rather than setting
 * bit 8 in the basic pending register forcing us to check the pending_1
 * register, the bit 11 of the basic register is set as a shortcut to
 * pending_1. This way, most of the time we only have to check the basic
 * pending register to service an IRQ.
 */

#define MODULE IRQ

#include <irq.h>
#include <log.h>
#include <platform.h>

static volatile irq_reg_t *irq_reg = (irq_reg_t *)IRQ_BASE;

static irq_service_routine_t irq_service_routines[96];

/*
 * Register a service routine with the interrupt handler
 */
void irq_register_service_routine(irq_service_routine_t isr, int pos)
{
	irq_service_routines[pos] = isr;
}

/*
 * Handle IRQ in bank 1 or 2
 *
 * If bit 8 or 9 was set in the basic pending register, there is an
 * IRQ waiting for us in bank 1 or 2 (respectively). This routine
 * checks the appropriate bank and invokes the correct handler.
 */
static inline void irq_handle_pending(int bank)
{
	int bit;
	uint32_t pending = irq_reg->pending[bank-1];

	while (pending) {
		/* find the next set bit */
		bit = 31 - __builtin_clz(pending);
		(irq_service_routines[bank * 64 + bit])();
		pending ^= (1 << bit); 
	}
}

/*
 * Service an interrupt in bank 1
 */
void irq_handle_bank_1_pending(void)
{
	irq_handle_pending(1);
}

/*
 * Service an interrupt in bank 2
 */
void irq_handle_bank_2_pending(void)
{
	irq_handle_pending(2);
}

/*
 * Initialize the interrupt service routine
 */
void irq_init()
{
	irq_register_service_routine(irq_handle_bank_1_pending, 8);
	irq_register_service_routine(irq_handle_bank_2_pending, 9);
}

/*
 * Interrupt handler
 *
 * When servicing an IRQ, we only check the basic pending register.
 * If an IRQ was generated by a peripheral mapped to bank 1 or 2, bit
 * 8 or 9 (respectively) will be set. The IRQ handlers for these two
 * bits will check the corresponding pending register and finish servicing
 * the IRQ.
 */
void handle_irq()
{
	int bit;
	uint32_t pending;

	log(DEBUG, "basic_pend: 0x%x, pend_1: 0x%x, pend_2: 0x%x",
			irq_reg->basic_pending, irq_reg->pending[1],
			irq_reg->pending[1]);
	log(DEBUG, "basic_enbl: 0x%x, enbl_1: 0x%x, enbl_2: 0x%x",
			irq_reg->basic_enable, irq_reg->enable[0],
			irq_reg->enable[1]);
	log(DEBUG, "basic_dabl: 0x%x, dabl_1: 0x%x, dabl_2: 0x%x",
			irq_reg->basic_disable, irq_reg->disable[0],
			irq_reg->disable[1]);

	/* check basic pending register (bank 0) */
	irq_handle_pending(0);
}

void service_undefined()
{
	log(WARN, "handling undefined");
}

void service_software_int()
{
	log(WARN, "handling software_int");
}

void service_prefetch_abort()
{
	log(WARN, "handling prefetch_abort");
}

void service_data_abort()
{
	log(WARN, "handling data_abort");
}

void service_fiq()
{
	log(WARN, "handling fiq");
}
